#!/usr/bin/perl -w

#    scriptor.pl: text interface to send APDU commands to a smart card
#    Copyright (C) 2001  Lionel Victor
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# $Id: scriptor,v 1.6 2001-10-16 07:37:42 rousseau Exp $

# $Log: not supported by cvs2svn $
# Revision 1.5  2001/09/05 07:35:59  rousseau
# Added CVS Log field
# Added documentation for -h argument
#

use Getopt::Std;
use PCSC;
use PCSC::Card;

use strict;

my %options;

my $hContext = new PCSC();
my $hCard;
my @out_buffer;
my $in_buffer;

die ("Could not create PCSC object: $PCSC::errno\n") unless defined $hContext;

getopt ("r:", \%options);

if ($options{h}) {
	print "Usage: $0 [-h] [-r reader] [file]\n";
	print "         -h: this help\n";
	print "  -r reader: specify to use the PCSC smart card reader named reader\n";
	print "             By defaults the first one found is used so you\n";
	print "             don't have to specify anything if you just have\n";
	print "             one reader\n";
	print "       file: file containing APDUs\n";
	exit (0);
}

if ($options{r}) {
	$hCard = new PCSC::Card ($hContext, $options{r});
	die ("Can't allocate PCSC::Card object: $PCSC::errno\n") unless defined $hCard;
	print STDERR "Using given card reader: $options{r}\n";
} else {
	my @readers_list = $hContext->ListReaders ();
	die ("Can't get readers list: $PCSC::errno\n") unless defined $readers_list[0];
	print STDERR "No reader given: using $readers_list[0]\n";
	$hCard = new PCSC::Card ($hContext, $readers_list[0]);
	die ("Can't allocate PCSC::Card object: $PCSC::errno\n") unless defined $hCard;
}

if ($ARGV[0]) {
	open (IN_FILEHANDLE, "<$ARGV[0]") or die ("Can't open $ARGV[0]: $!\n");
	print STDERR "Using given file: $ARGV[0]\n";
} else {
	*IN_FILEHANDLE = *STDIN;
	print STDERR "Reading commands from STDIN\n";
}

*OUT_FILEHANDLE = *STDOUT;

while (<IN_FILEHANDLE>) {
	my $tmp_value;
	my ($SendData, $RecvData, $cmd);

	last if /exit/;
	next if /^\s*$/;
	next if /^#/;

	if (/reset/) {
		print OUT_FILEHANDLE "> RESET\n";
		if (defined $hCard->Reconnect ($PCSC::SCARD_SHARE_EXCLUSIVE,
		                   $PCSC::SCARD_PROTOCOL_T0,
						   $PCSC::SCARD_RESET_CARD)) {
			print OUT_FILEHANDLE "< OK\n";
		} else {
			print OUT_FILEHANDLE "< KO: $PCSC::errno\n";
		}
		next;
	}
	chomp;
	$cmd = $_;
	$SendData = PCSC::ascii_to_array($cmd);

	print OUT_FILEHANDLE "> $cmd\n";
	$RecvData = $hCard->Transmit($SendData);
	die ("Can't get info: $PCSC::errno\n") unless defined $RecvData;
	print OUT_FILEHANDLE "< " . PCSC::array_to_ascii($RecvData) . "\n";
}

close (IN_FILEHANDLE);
$hCard->Disconnect($PCSC::SCARD_LEAVE_CARD);
$hCard = undef;
$hContext = undef;

# End of File

